(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{338:function(e,t,s){"use strict";s.r(t);var a=s(6),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"assets"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#assets"}},[e._v("#")]),e._v(" Assets")]),e._v(" "),s("h2",{attrs:{id:"asset-management"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asset-management"}},[e._v("#")]),e._v(" Asset Management")]),e._v(" "),s("p",[e._v("Since Cargo only deals with code, a "),s("code",[e._v("build.rs")]),e._v(" script was created to facilitate copying the assets source folder to it's destination directory relative to the built executable.")]),e._v(" "),s("p",[e._v("There also exists an "),s("code",[e._v("asset")]),e._v(" module that exports a helper function "),s("code",[e._v("assets_path()")]),e._v(" to obtain the assets directory at runtime, to make loading the assets easier.")]),e._v(" "),s("h2",{attrs:{id:"including-resources"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#including-resources"}},[e._v("#")]),e._v(" Including resources")]),e._v(" "),s("p",[e._v("Some files are loaded directly into the application binary at compile time. This includes the imgui font and the shaders. Rust has a couple of helper macros that make this trivial, namely, "),s("code",[e._v("include_bytes!()")]),e._v(" and "),s("code",[e._v("include_str!()")]),e._v(". This is something that seems incredibly simple, but cannot be done with just C++ without changing the original file to make it a raw string. "),s("em",[e._v("50 points to Rustlepuff!")]),e._v(" üßô‚Äç‚ôÇÔ∏è")])])}),[],!1,null,null,null);t.default=i.exports}}]);