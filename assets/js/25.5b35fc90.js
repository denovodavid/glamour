(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{347:function(e,t,a){"use strict";a.r(t);var o=a(6),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"tests-docs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tests-docs"}},[e._v("#")]),e._v(" Tests & Docs")]),e._v(" "),a("p",[e._v("Details on testing, documentation, and benchmarks.")]),e._v(" "),a("h2",{attrs:{id:"tests"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tests"}},[e._v("#")]),e._v(" Tests")]),e._v(" "),a("p",[e._v("The Rust Toolchain comes with built in testing and documentation tool, they can even be combined. Now, there aren't a lot of tests in source code at the time of writing, as a lot of it is OpenGL code, which is notoriously hard to ensure robustness because of the multitude of versions and implementations. However, a few test experiments were completed as part of a bit of documentation, as rust will compile doc-comment example code and run it as integration tests.")]),e._v(" "),a("h2",{attrs:{id:"documentation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#documentation"}},[e._v("#")]),e._v(" Documentation")]),e._v(" "),a("p",[e._v("There also isn't a lot of source code documentation available, but Cargo can generate API documentation from the source code into a web page. So, when code is pushed to the GitHub repository, it's built, tested, and the documentation is generated and put up on this website "),a("a",{attrs:{href:"https://glamour.davidhol.land/doc/glamour/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),a("OutboundLink")],1),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"benchmarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#benchmarks"}},[e._v("#")]),e._v(" Benchmarks")]),e._v(" "),a("p",[e._v("Cargo has benchmark tests in nightly preview at the moment, but the "),a("code",[e._v("criterion")]),e._v(" crate exists to aid in benchmarking functions in the meantime. The benchmarks run a some arbitrary code a bunch of times — generally thousands — and takes a sample of those to compare to the previous run, so the developer can track performance trends. These benchmarks have been used to improve the performance of the "),a("code",[e._v("Transform")]),e._v(" matrix calculation (which runs thousands of times a frame), and confirm where multi-threading improves performance (mainly by parallelising all those matrix transformations).")])])}),[],!1,null,null,null);t.default=s.exports}}]);